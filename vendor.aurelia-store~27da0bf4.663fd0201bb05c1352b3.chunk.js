(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-store~27da0bf4"],{

/***/ "aurelia-store":
/*!*************************************************************************!*\
  !*** ./node_modules/aurelia-store/dist/native-modules/aurelia-store.js ***!
  \*************************************************************************/
/*! exports provided: configure, PerformanceMeasurement, UnregisteredActionError, Store, dispatchify, executeSteps, jump, nextStateHistory, applyLimits, isStateHistory, DEFAULT_LOCAL_STORAGE_KEY, MiddlewarePlacement, logMiddleware, localStorageMiddleware, rehydrateFromLocalStorage, LogLevel, LoggerIndexed, getLogType, connectTo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerformanceMeasurement\", function() { return PerformanceMeasurement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnregisteredActionError\", function() { return UnregisteredActionError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dispatchify\", function() { return dispatchify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"executeSteps\", function() { return executeSteps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jump\", function() { return jump; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nextStateHistory\", function() { return nextStateHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyLimits\", function() { return applyLimits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStateHistory\", function() { return isStateHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_LOCAL_STORAGE_KEY\", function() { return DEFAULT_LOCAL_STORAGE_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MiddlewarePlacement\", function() { return MiddlewarePlacement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logMiddleware\", function() { return logMiddleware; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localStorageMiddleware\", function() { return localStorageMiddleware; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rehydrateFromLocalStorage\", function() { return rehydrateFromLocalStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return LogLevel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoggerIndexed\", function() { return LoggerIndexed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLogType\", function() { return getLogType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectTo\", function() { return connectTo; });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ \"DtyJ\");\n/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-dependency-injection */ \"3U8n\");\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"ahDk\");\n\n\n\n\n\n\n/* istanbul ignore next */\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#Polyfill\nif (!Object.entries) {\n    Object.entries = function (obj) {\n        var ownProps = Object.keys(obj), i = ownProps.length, resArray = new Array(i); // preallocate the Array\n        while (i--) {\n            resArray[i] = [ownProps[i], obj[ownProps[i]]];\n        }\n        return resArray;\n    };\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nfunction jump(state, n) {\n    if (!isStateHistory(state)) {\n        return state;\n    }\n    if (n > 0)\n        return jumpToFuture(state, n - 1);\n    if (n < 0)\n        return jumpToPast(state, state.past.length + n);\n    return state;\n}\nfunction jumpToFuture(state, index) {\n    if (index < 0 || index >= state.future.length) {\n        return state;\n    }\n    var past = state.past, future = state.future, present = state.present;\n    var newPast = past.concat([present], future.slice(0, index));\n    var newPresent = future[index];\n    var newFuture = future.slice(index + 1);\n    return { past: newPast, present: newPresent, future: newFuture };\n}\nfunction jumpToPast(state, index) {\n    if (index < 0 || index >= state.past.length) {\n        return state;\n    }\n    var past = state.past, future = state.future, present = state.present;\n    var newPast = past.slice(0, index);\n    var newFuture = past.slice(index + 1).concat([present], future);\n    var newPresent = past[index];\n    return { past: newPast, present: newPresent, future: newFuture };\n}\nfunction nextStateHistory(presentStateHistory, nextPresent) {\n    return Object.assign({}, presentStateHistory, {\n        past: presentStateHistory.past.concat([presentStateHistory.present]),\n        present: nextPresent,\n        future: []\n    });\n}\nfunction applyLimits(state, limit) {\n    if (isStateHistory(state)) {\n        if (state.past.length > limit) {\n            state.past = state.past.slice(state.past.length - limit);\n        }\n        if (state.future.length > limit) {\n            state.future = state.future.slice(0, limit);\n        }\n    }\n    return state;\n}\nfunction isStateHistory(history) {\n    return typeof history.present !== \"undefined\" &&\n        typeof history.future !== \"undefined\" &&\n        typeof history.past !== \"undefined\" &&\n        Array.isArray(history.future) &&\n        Array.isArray(history.past);\n}\n\nvar DEFAULT_LOCAL_STORAGE_KEY = \"aurelia-store-state\";\nvar MiddlewarePlacement;\n(function (MiddlewarePlacement) {\n    MiddlewarePlacement[\"Before\"] = \"before\";\n    MiddlewarePlacement[\"After\"] = \"after\";\n})(MiddlewarePlacement || (MiddlewarePlacement = {}));\nfunction logMiddleware(state, _, settings) {\n    var logType = settings && settings.logType && console.hasOwnProperty(settings.logType) ? settings.logType : \"log\";\n    console[logType](\"New state: \", state);\n}\nfunction localStorageMiddleware(state, _, settings) {\n    if (aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.localStorage) {\n        var key = settings && settings.key || DEFAULT_LOCAL_STORAGE_KEY;\n        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.localStorage.setItem(key, JSON.stringify(state));\n    }\n}\nfunction rehydrateFromLocalStorage(state, key) {\n    if (!aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.localStorage) {\n        return state;\n    }\n    var storedState = aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.localStorage.getItem(key || DEFAULT_LOCAL_STORAGE_KEY);\n    if (!storedState) {\n        return state;\n    }\n    try {\n        return JSON.parse(storedState);\n    }\n    catch (e) { }\n    return state;\n}\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"trace\"] = \"trace\";\n    LogLevel[\"debug\"] = \"debug\";\n    LogLevel[\"info\"] = \"info\";\n    LogLevel[\"log\"] = \"log\";\n    LogLevel[\"warn\"] = \"warn\";\n    LogLevel[\"error\"] = \"error\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerIndexed = /** @class */ (function (_super) {\n    __extends(LoggerIndexed, _super);\n    function LoggerIndexed() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LoggerIndexed;\n}(aurelia_logging__WEBPACK_IMPORTED_MODULE_2__[\"Logger\"]));\nfunction getLogType(options, definition, defaultLevel) {\n    if (definition &&\n        options.logDefinitions &&\n        options.logDefinitions.hasOwnProperty(definition) &&\n        options.logDefinitions[definition] &&\n        Object.values(LogLevel).includes(options.logDefinitions[definition])) {\n        return options.logDefinitions[definition];\n    }\n    return defaultLevel;\n}\n\nvar PerformanceMeasurement;\n(function (PerformanceMeasurement) {\n    PerformanceMeasurement[\"StartEnd\"] = \"startEnd\";\n    PerformanceMeasurement[\"All\"] = \"all\";\n})(PerformanceMeasurement || (PerformanceMeasurement = {}));\nvar UnregisteredActionError = /** @class */ (function (_super) {\n    __extends(UnregisteredActionError, _super);\n    function UnregisteredActionError(reducer) {\n        return _super.call(this, \"Tried to dispatch an unregistered action \" + (reducer && (typeof reducer === \"string\" ? reducer : reducer.name))) || this;\n    }\n    return UnregisteredActionError;\n}(Error));\nvar Store = /** @class */ (function () {\n    function Store(initialState, options) {\n        this.initialState = initialState;\n        this.logger = Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_2__[\"getLogger\"])(\"aurelia-store\");\n        this.devToolsAvailable = false;\n        this.actions = new Map();\n        this.middlewares = new Map();\n        this.dispatchQueue = [];\n        this.options = options || {};\n        var isUndoable = this.options.history && this.options.history.undoable === true;\n        this._state = new rxjs__WEBPACK_IMPORTED_MODULE_0__[\"BehaviorSubject\"](initialState);\n        this.state = this._state.asObservable();\n        if (!this.options.devToolsOptions || this.options.devToolsOptions.disable !== true) {\n            this.setupDevTools();\n        }\n        if (isUndoable) {\n            this.registerHistoryMethods();\n        }\n    }\n    Store.prototype.registerMiddleware = function (reducer, placement, settings) {\n        this.middlewares.set(reducer, { placement: placement, settings: settings });\n    };\n    Store.prototype.unregisterMiddleware = function (reducer) {\n        if (this.middlewares.has(reducer)) {\n            this.middlewares.delete(reducer);\n        }\n    };\n    Store.prototype.isMiddlewareRegistered = function (middleware) {\n        return this.middlewares.has(middleware);\n    };\n    Store.prototype.registerAction = function (name, reducer) {\n        if (reducer.length === 0) {\n            throw new Error(\"The reducer is expected to have one or more parameters, where the first will be the present state\");\n        }\n        this.actions.set(reducer, { type: name });\n    };\n    Store.prototype.unregisterAction = function (reducer) {\n        if (this.actions.has(reducer)) {\n            this.actions.delete(reducer);\n        }\n    };\n    Store.prototype.isActionRegistered = function (reducer) {\n        if (typeof reducer === \"string\") {\n            return Array.from(this.actions).find(function (action) { return action[1].type === reducer; }) !== undefined;\n        }\n        return this.actions.has(reducer);\n    };\n    Store.prototype.resetToState = function (state) {\n        this._state.next(state);\n    };\n    Store.prototype.dispatch = function (reducer) {\n        var params = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            params[_i - 1] = arguments[_i];\n        }\n        var action = this.lookupAction(reducer);\n        if (!action) {\n            return Promise.reject(new UnregisteredActionError(reducer));\n        }\n        return this.queueDispatch([{\n                reducer: action,\n                params: params\n            }]);\n    };\n    Store.prototype.pipe = function (reducer) {\n        var _this = this;\n        var params = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            params[_i - 1] = arguments[_i];\n        }\n        var pipeline = [];\n        var dispatchPipe = {\n            dispatch: function () { return _this.queueDispatch(pipeline); },\n            pipe: function (nextReducer) {\n                var nextParams = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    nextParams[_i - 1] = arguments[_i];\n                }\n                var action = _this.lookupAction(nextReducer);\n                if (!action) {\n                    throw new UnregisteredActionError(reducer);\n                }\n                pipeline.push({ reducer: action, params: nextParams });\n                return dispatchPipe;\n            }\n        };\n        return dispatchPipe.pipe.apply(dispatchPipe, [reducer].concat(params));\n    };\n    Store.prototype.lookupAction = function (reducer) {\n        if (typeof reducer === \"string\") {\n            var result = Array.from(this.actions).find(function (_a) {\n                var _ = _a[0], action = _a[1];\n                return action.type === reducer;\n            });\n            if (result) {\n                return result[0];\n            }\n        }\n        else if (this.actions.has(reducer)) {\n            return reducer;\n        }\n        return undefined;\n    };\n    Store.prototype.queueDispatch = function (actions) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.dispatchQueue.push({ actions: actions, resolve: resolve, reject: reject });\n            if (_this.dispatchQueue.length === 1) {\n                _this.handleQueue();\n            }\n        });\n    };\n    Store.prototype.handleQueue = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var queueItem, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.dispatchQueue.length > 0)) return [3 /*break*/, 5];\n                        queueItem = this.dispatchQueue[0];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.internalDispatch(queueItem.actions)];\n                    case 2:\n                        _a.sent();\n                        queueItem.resolve();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        queueItem.reject(e_1);\n                        return [3 /*break*/, 4];\n                    case 4:\n                        this.dispatchQueue.shift();\n                        this.handleQueue();\n                        _a.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Store.prototype.internalDispatch = function (actions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var unregisteredAction, pipedActions, callingAction, beforeMiddleswaresResult, result, _i, pipedActions_1, action, resultingState, measures, marks, totalDuration;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        unregisteredAction = actions.find(function (a) { return !_this.actions.has(a.reducer); });\n                        if (unregisteredAction) {\n                            throw new UnregisteredActionError(unregisteredAction.reducer);\n                        }\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.mark(\"dispatch-start\");\n                        pipedActions = actions.map(function (a) { return ({\n                            type: _this.actions.get(a.reducer).type,\n                            params: a.params,\n                            reducer: a.reducer\n                        }); });\n                        callingAction = {\n                            name: pipedActions.map(function (a) { return a.type; }).join(\"->\"),\n                            params: pipedActions.reduce(function (p, a) { return p.concat(a.params); }, []),\n                            pipedActions: pipedActions.map(function (a) { return ({\n                                name: a.type,\n                                params: a.params\n                            }); })\n                        };\n                        if (this.options.logDispatchedActions) {\n                            this.logger[getLogType(this.options, \"dispatchedActions\", LogLevel.info)](\"Dispatching: \" + callingAction.name);\n                        }\n                        return [4 /*yield*/, this.executeMiddlewares(this._state.getValue(), MiddlewarePlacement.Before, callingAction)];\n                    case 1:\n                        beforeMiddleswaresResult = _a.sent();\n                        if (beforeMiddleswaresResult === false) {\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMarks();\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMeasures();\n                            return [2 /*return*/];\n                        }\n                        result = beforeMiddleswaresResult;\n                        _i = 0, pipedActions_1 = pipedActions;\n                        _a.label = 2;\n                    case 2:\n                        if (!(_i < pipedActions_1.length)) return [3 /*break*/, 5];\n                        action = pipedActions_1[_i];\n                        return [4 /*yield*/, action.reducer.apply(action, [result].concat(action.params))];\n                    case 3:\n                        result = _a.sent();\n                        if (result === false) {\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMarks();\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMeasures();\n                            return [2 /*return*/];\n                        }\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.mark(\"dispatch-after-reducer-\" + action.type);\n                        if (!result && typeof result !== \"object\") {\n                            throw new Error(\"The reducer has to return a new state\");\n                        }\n                        _a.label = 4;\n                    case 4:\n                        _i++;\n                        return [3 /*break*/, 2];\n                    case 5: return [4 /*yield*/, this.executeMiddlewares(result, MiddlewarePlacement.After, callingAction)];\n                    case 6:\n                        resultingState = _a.sent();\n                        if (resultingState === false) {\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMarks();\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMeasures();\n                            return [2 /*return*/];\n                        }\n                        if (isStateHistory(resultingState) &&\n                            this.options.history &&\n                            this.options.history.limit) {\n                            resultingState = applyLimits(resultingState, this.options.history.limit);\n                        }\n                        this._state.next(resultingState);\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.mark(\"dispatch-end\");\n                        if (this.options.measurePerformance === PerformanceMeasurement.StartEnd) {\n                            aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.measure(\"startEndDispatchDuration\", \"dispatch-start\", \"dispatch-end\");\n                            measures = aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.getEntriesByName(\"startEndDispatchDuration\");\n                            this.logger[getLogType(this.options, \"performanceLog\", LogLevel.info)](\"Total duration \" + measures[0].duration + \" of dispatched action \" + callingAction.name + \":\", measures);\n                        }\n                        else if (this.options.measurePerformance === PerformanceMeasurement.All) {\n                            marks = aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.getEntriesByType(\"mark\");\n                            totalDuration = marks[marks.length - 1].startTime - marks[0].startTime;\n                            this.logger[getLogType(this.options, \"performanceLog\", LogLevel.info)](\"Total duration \" + totalDuration + \" of dispatched action \" + callingAction.name + \":\", marks);\n                        }\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMarks();\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.clearMeasures();\n                        this.updateDevToolsState({ type: callingAction.name, params: callingAction.params }, resultingState);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Store.prototype.executeMiddlewares = function (state, placement, action) {\n        var _this = this;\n        return Array.from(this.middlewares)\n            .filter(function (middleware) { return middleware[1].placement === placement; })\n            .reduce(function (prev, curr, _, _arr) { return __awaiter(_this, void 0, void 0, function () {\n            var result, _a, _b, _c, e_2;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 7, 8]);\n                        _b = (_a = curr)[0];\n                        return [4 /*yield*/, prev];\n                    case 1: return [4 /*yield*/, _b.apply(_a, [_d.sent(), this._state.getValue(), curr[1].settings, action])];\n                    case 2:\n                        result = _d.sent();\n                        if (result === false) {\n                            _arr = [];\n                            return [2 /*return*/, false];\n                        }\n                        _c = result;\n                        if (_c) return [3 /*break*/, 4];\n                        return [4 /*yield*/, prev];\n                    case 3:\n                        _c = (_d.sent());\n                        _d.label = 4;\n                    case 4: return [2 /*return*/, _c];\n                    case 5:\n                        e_2 = _d.sent();\n                        if (this.options.propagateError) {\n                            _arr = [];\n                            throw e_2;\n                        }\n                        return [4 /*yield*/, prev];\n                    case 6: return [2 /*return*/, _d.sent()];\n                    case 7:\n                        aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].performance.mark(\"dispatch-\" + placement + \"-\" + curr[0].name);\n                        return [7 /*endfinally*/];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        }); }, state);\n    };\n    Store.prototype.setupDevTools = function () {\n        var _this = this;\n        if (aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.devToolsExtension) {\n            this.logger[getLogType(this.options, \"devToolsStatus\", LogLevel.debug)](\"DevTools are available\");\n            this.devToolsAvailable = true;\n            this.devTools = aurelia_pal__WEBPACK_IMPORTED_MODULE_3__[\"PLATFORM\"].global.__REDUX_DEVTOOLS_EXTENSION__.connect(this.options.devToolsOptions);\n            this.devTools.init(this.initialState);\n            this.devTools.subscribe(function (message) {\n                _this.logger[getLogType(_this.options, \"devToolsStatus\", LogLevel.debug)](\"DevTools sent change \" + message.type);\n                if (message.type === \"DISPATCH\") {\n                    _this._state.next(JSON.parse(message.state));\n                }\n            });\n        }\n    };\n    Store.prototype.updateDevToolsState = function (action, state) {\n        if (this.devToolsAvailable) {\n            this.devTools.send(action, state);\n        }\n    };\n    Store.prototype.registerHistoryMethods = function () {\n        this.registerAction(\"jump\", jump);\n    };\n    return Store;\n}());\nfunction dispatchify(action) {\n    var store = aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__[\"Container\"].instance.get(Store);\n    return function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n        }\n        return store.dispatch.apply(store, [action].concat(params));\n    };\n}\n\nfunction executeSteps(store, shouldLogResults) {\n    var steps = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        steps[_i - 2] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n        var logStep, tryStep, lastStep;\n        return __generator(this, function (_a) {\n            logStep = function (step, stepIdx) { return function (res) {\n                if (shouldLogResults) {\n                    console.group(\"Step \" + stepIdx);\n                    console.log(res);\n                    console.groupEnd();\n                }\n                step(res);\n            }; };\n            tryStep = function (step, reject) {\n                return function (res) {\n                    try {\n                        step(res);\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                };\n            };\n            lastStep = function (step, resolve) {\n                return function (res) {\n                    step(res);\n                    resolve();\n                };\n            };\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n                    var currentStep = 0;\n                    steps.slice(0, -1).forEach(function (step) {\n                        store.state.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"skip\"])(currentStep), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"take\"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"delay\"])(0)).subscribe(tryStep(logStep(step, currentStep), reject));\n                        currentStep++;\n                    });\n                    store.state.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"skip\"])(currentStep), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"take\"])(1)).subscribe(lastStep(tryStep(logStep(steps[steps.length - 1], currentStep), reject), resolve));\n                })];\n        });\n    });\n}\n\nvar defaultSelector = function (store) { return store.state; };\nfunction connectTo(settings) {\n    var $store;\n    // const store = Container.instance.get(Store) as Store<T>;\n    var _settings = __assign({ selector: typeof settings === \"function\" ? settings : defaultSelector }, settings);\n    function getSource(selector) {\n        // if for some reason getSource is invoked before setup (bind lifecycle, typically)\n        // then we have no choice but to get the store instance from global container instance\n        // otherwise, assume that $store variable in the closure would be already assigned the right\n        // value from created callback\n        // Could also be in situation where it doesn't come from custom element, or some exotic setups/scenarios\n        var store = $store || ($store = aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__[\"Container\"].instance.get(Store));\n        var source = selector(store);\n        if (source instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__[\"Observable\"]) {\n            return source;\n        }\n        return store.state;\n    }\n    function createSelectors() {\n        var _a;\n        var isSelectorObj = typeof _settings.selector === \"object\";\n        var fallbackSelector = (_a = {},\n            _a[_settings.target || \"state\"] = _settings.selector || defaultSelector,\n            _a);\n        return Object.entries(__assign({}, (isSelectorObj ? _settings.selector : fallbackSelector))).map(function (_a) {\n            var target = _a[0], selector = _a[1];\n            var _b;\n            return ({\n                targets: _settings.target && isSelectorObj ? [_settings.target, target] : [target],\n                selector: selector,\n                // numbers are the starting index to slice all the change handling args, \n                // which are prop name, new state and old state\n                changeHandlers: (_b = {},\n                    _b[_settings.onChanged || \"\"] = 1,\n                    _b[(_settings.target || target) + \"Changed\"] = _settings.target ? 0 : 1,\n                    _b[\"propertyChanged\"] = 0,\n                    _b)\n            });\n        });\n    }\n    return function (target) {\n        var originalCreated = target.prototype.created;\n        var originalSetup = typeof settings === \"object\" && settings.setup\n            ? target.prototype[settings.setup]\n            : target.prototype.bind;\n        var originalTeardown = typeof settings === \"object\" && settings.teardown\n            ? target.prototype[settings.teardown]\n            : target.prototype.unbind;\n        // only override if prototype callback is a function\n        if (typeof originalCreated === \"function\" || originalCreated === undefined) {\n            target.prototype.created = function created(_, view) {\n                // here we relies on the fact that the class Store\n                // has not been registered somewhere in one of child containers, instead of root container\n                // if there is any issue with this approach, needs to walk all the way up to resolve from root\n                // typically like invoking from global Container.instance\n                $store = view.container.get(Store);\n                if (originalCreated !== undefined) {\n                    return originalCreated.call(this, _, view);\n                }\n            };\n        }\n        target.prototype[typeof settings === \"object\" && settings.setup ? settings.setup : \"bind\"] = function () {\n            var _this = this;\n            if (typeof settings == \"object\" &&\n                typeof settings.onChanged === \"string\" &&\n                !(settings.onChanged in this)) {\n                throw new Error(\"Provided onChanged handler does not exist on target VM\");\n            }\n            this._stateSubscriptions = createSelectors().map(function (s) { return getSource(s.selector).subscribe(function (state) {\n                var lastTargetIdx = s.targets.length - 1;\n                var oldState = s.targets.reduce(function (accu, curr) {\n                    if (accu === void 0) { accu = {}; }\n                    return accu[curr];\n                }, _this);\n                Object.entries(s.changeHandlers).forEach(function (_a) {\n                    var handlerName = _a[0], args = _a[1];\n                    if (handlerName in _this) {\n                        _this[handlerName].apply(_this, [s.targets[lastTargetIdx], state, oldState].slice(args, 3));\n                    }\n                });\n                s.targets.reduce(function (accu, curr, idx) {\n                    accu[curr] = idx === lastTargetIdx ? state : accu[curr] || {};\n                    return accu[curr];\n                }, _this);\n            }); });\n            if (originalSetup) {\n                return originalSetup.apply(this, arguments);\n            }\n        };\n        target.prototype[typeof settings === \"object\" && settings.teardown ? settings.teardown : \"unbind\"] = function () {\n            if (this._stateSubscriptions && Array.isArray(this._stateSubscriptions)) {\n                this._stateSubscriptions.forEach(function (sub) {\n                    if (sub instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__[\"Subscription\"] && sub.closed === false) {\n                        sub.unsubscribe();\n                    }\n                });\n            }\n            if (originalTeardown) {\n                return originalTeardown.apply(this, arguments);\n            }\n        };\n    };\n}\n\nfunction configure(aurelia, options) {\n    if (!options || !options.initialState) {\n        throw new Error(\"initialState must be provided via options\");\n    }\n    var initState = options.initialState;\n    if (options && options.history && options.history.undoable && !isStateHistory(options.initialState)) {\n        initState = { past: [], present: options.initialState, future: [] };\n    }\n    delete options.initialState;\n    aurelia.container\n        .registerInstance(Store, new Store(initState, options));\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! promise-polyfill */ \"B/eG\")[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVyZWxpYS1zdG9yZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXN0b3JlL2Rpc3QvbmF0aXZlLW1vZHVsZXMvYXVyZWxpYS1zdG9yZS5qcz9hN2MxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICdhdXJlbGlhLWRlcGVuZGVuY3ktaW5qZWN0aW9uJztcbmltcG9ydCB7IExvZ2dlciwgZ2V0TG9nZ2VyIH0gZnJvbSAnYXVyZWxpYS1sb2dnaW5nJztcbmltcG9ydCB7IFBMQVRGT1JNIH0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuaW1wb3J0IHsgc2tpcCwgdGFrZSwgZGVsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZW50cmllcyNQb2x5ZmlsbFxuaWYgKCFPYmplY3QuZW50cmllcykge1xuICAgIE9iamVjdC5lbnRyaWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgb3duUHJvcHMgPSBPYmplY3Qua2V5cyhvYmopLCBpID0gb3duUHJvcHMubGVuZ3RoLCByZXNBcnJheSA9IG5ldyBBcnJheShpKTsgLy8gcHJlYWxsb2NhdGUgdGhlIEFycmF5XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJlc0FycmF5W2ldID0gW293blByb3BzW2ldLCBvYmpbb3duUHJvcHNbaV1dXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzQXJyYXk7XG4gICAgfTtcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBqdW1wKHN0YXRlLCBuKSB7XG4gICAgaWYgKCFpc1N0YXRlSGlzdG9yeShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBpZiAobiA+IDApXG4gICAgICAgIHJldHVybiBqdW1wVG9GdXR1cmUoc3RhdGUsIG4gLSAxKTtcbiAgICBpZiAobiA8IDApXG4gICAgICAgIHJldHVybiBqdW1wVG9QYXN0KHN0YXRlLCBzdGF0ZS5wYXN0Lmxlbmd0aCArIG4pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGp1bXBUb0Z1dHVyZShzdGF0ZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0YXRlLmZ1dHVyZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICB2YXIgcGFzdCA9IHN0YXRlLnBhc3QsIGZ1dHVyZSA9IHN0YXRlLmZ1dHVyZSwgcHJlc2VudCA9IHN0YXRlLnByZXNlbnQ7XG4gICAgdmFyIG5ld1Bhc3QgPSBwYXN0LmNvbmNhdChbcHJlc2VudF0sIGZ1dHVyZS5zbGljZSgwLCBpbmRleCkpO1xuICAgIHZhciBuZXdQcmVzZW50ID0gZnV0dXJlW2luZGV4XTtcbiAgICB2YXIgbmV3RnV0dXJlID0gZnV0dXJlLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHsgcGFzdDogbmV3UGFzdCwgcHJlc2VudDogbmV3UHJlc2VudCwgZnV0dXJlOiBuZXdGdXR1cmUgfTtcbn1cbmZ1bmN0aW9uIGp1bXBUb1Bhc3Qoc3RhdGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdGF0ZS5wYXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHZhciBwYXN0ID0gc3RhdGUucGFzdCwgZnV0dXJlID0gc3RhdGUuZnV0dXJlLCBwcmVzZW50ID0gc3RhdGUucHJlc2VudDtcbiAgICB2YXIgbmV3UGFzdCA9IHBhc3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIHZhciBuZXdGdXR1cmUgPSBwYXN0LnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KFtwcmVzZW50XSwgZnV0dXJlKTtcbiAgICB2YXIgbmV3UHJlc2VudCA9IHBhc3RbaW5kZXhdO1xuICAgIHJldHVybiB7IHBhc3Q6IG5ld1Bhc3QsIHByZXNlbnQ6IG5ld1ByZXNlbnQsIGZ1dHVyZTogbmV3RnV0dXJlIH07XG59XG5mdW5jdGlvbiBuZXh0U3RhdGVIaXN0b3J5KHByZXNlbnRTdGF0ZUhpc3RvcnksIG5leHRQcmVzZW50KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByZXNlbnRTdGF0ZUhpc3RvcnksIHtcbiAgICAgICAgcGFzdDogcHJlc2VudFN0YXRlSGlzdG9yeS5wYXN0LmNvbmNhdChbcHJlc2VudFN0YXRlSGlzdG9yeS5wcmVzZW50XSksXG4gICAgICAgIHByZXNlbnQ6IG5leHRQcmVzZW50LFxuICAgICAgICBmdXR1cmU6IFtdXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhcHBseUxpbWl0cyhzdGF0ZSwgbGltaXQpIHtcbiAgICBpZiAoaXNTdGF0ZUhpc3Rvcnkoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5wYXN0Lmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICBzdGF0ZS5wYXN0ID0gc3RhdGUucGFzdC5zbGljZShzdGF0ZS5wYXN0Lmxlbmd0aCAtIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZnV0dXJlLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICBzdGF0ZS5mdXR1cmUgPSBzdGF0ZS5mdXR1cmUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGhpc3RvcnkucHJlc2VudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgaGlzdG9yeS5mdXR1cmUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIGhpc3RvcnkucGFzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGhpc3RvcnkuZnV0dXJlKSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGhpc3RvcnkucGFzdCk7XG59XG5cbnZhciBERUZBVUxUX0xPQ0FMX1NUT1JBR0VfS0VZID0gXCJhdXJlbGlhLXN0b3JlLXN0YXRlXCI7XG52YXIgTWlkZGxld2FyZVBsYWNlbWVudDtcbihmdW5jdGlvbiAoTWlkZGxld2FyZVBsYWNlbWVudCkge1xuICAgIE1pZGRsZXdhcmVQbGFjZW1lbnRbXCJCZWZvcmVcIl0gPSBcImJlZm9yZVwiO1xuICAgIE1pZGRsZXdhcmVQbGFjZW1lbnRbXCJBZnRlclwiXSA9IFwiYWZ0ZXJcIjtcbn0pKE1pZGRsZXdhcmVQbGFjZW1lbnQgfHwgKE1pZGRsZXdhcmVQbGFjZW1lbnQgPSB7fSkpO1xuZnVuY3Rpb24gbG9nTWlkZGxld2FyZShzdGF0ZSwgXywgc2V0dGluZ3MpIHtcbiAgICB2YXIgbG9nVHlwZSA9IHNldHRpbmdzICYmIHNldHRpbmdzLmxvZ1R5cGUgJiYgY29uc29sZS5oYXNPd25Qcm9wZXJ0eShzZXR0aW5ncy5sb2dUeXBlKSA/IHNldHRpbmdzLmxvZ1R5cGUgOiBcImxvZ1wiO1xuICAgIGNvbnNvbGVbbG9nVHlwZV0oXCJOZXcgc3RhdGU6IFwiLCBzdGF0ZSk7XG59XG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2VNaWRkbGV3YXJlKHN0YXRlLCBfLCBzZXR0aW5ncykge1xuICAgIGlmIChQTEFURk9STS5nbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIHZhciBrZXkgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5rZXkgfHwgREVGQVVMVF9MT0NBTF9TVE9SQUdFX0tFWTtcbiAgICAgICAgUExBVEZPUk0uZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWh5ZHJhdGVGcm9tTG9jYWxTdG9yYWdlKHN0YXRlLCBrZXkpIHtcbiAgICBpZiAoIVBMQVRGT1JNLmdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICB2YXIgc3RvcmVkU3RhdGUgPSBQTEFURk9STS5nbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5IHx8IERFRkFVTFRfTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgIGlmICghc3RvcmVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWRTdGF0ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtcInRyYWNlXCJdID0gXCJ0cmFjZVwiO1xuICAgIExvZ0xldmVsW1wiZGVidWdcIl0gPSBcImRlYnVnXCI7XG4gICAgTG9nTGV2ZWxbXCJpbmZvXCJdID0gXCJpbmZvXCI7XG4gICAgTG9nTGV2ZWxbXCJsb2dcIl0gPSBcImxvZ1wiO1xuICAgIExvZ0xldmVsW1wid2FyblwiXSA9IFwid2FyblwiO1xuICAgIExvZ0xldmVsW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xudmFyIExvZ2dlckluZGV4ZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZ2dlckluZGV4ZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9nZ2VySW5kZXhlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTG9nZ2VySW5kZXhlZDtcbn0oTG9nZ2VyKSk7XG5mdW5jdGlvbiBnZXRMb2dUeXBlKG9wdGlvbnMsIGRlZmluaXRpb24sIGRlZmF1bHRMZXZlbCkge1xuICAgIGlmIChkZWZpbml0aW9uICYmXG4gICAgICAgIG9wdGlvbnMubG9nRGVmaW5pdGlvbnMgJiZcbiAgICAgICAgb3B0aW9ucy5sb2dEZWZpbml0aW9ucy5oYXNPd25Qcm9wZXJ0eShkZWZpbml0aW9uKSAmJlxuICAgICAgICBvcHRpb25zLmxvZ0RlZmluaXRpb25zW2RlZmluaXRpb25dICYmXG4gICAgICAgIE9iamVjdC52YWx1ZXMoTG9nTGV2ZWwpLmluY2x1ZGVzKG9wdGlvbnMubG9nRGVmaW5pdGlvbnNbZGVmaW5pdGlvbl0pKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvZ0RlZmluaXRpb25zW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdExldmVsO1xufVxuXG52YXIgUGVyZm9ybWFuY2VNZWFzdXJlbWVudDtcbihmdW5jdGlvbiAoUGVyZm9ybWFuY2VNZWFzdXJlbWVudCkge1xuICAgIFBlcmZvcm1hbmNlTWVhc3VyZW1lbnRbXCJTdGFydEVuZFwiXSA9IFwic3RhcnRFbmRcIjtcbiAgICBQZXJmb3JtYW5jZU1lYXN1cmVtZW50W1wiQWxsXCJdID0gXCJhbGxcIjtcbn0pKFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQgfHwgKFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQgPSB7fSkpO1xudmFyIFVucmVnaXN0ZXJlZEFjdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnJlZ2lzdGVyZWRBY3Rpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnJlZ2lzdGVyZWRBY3Rpb25FcnJvcihyZWR1Y2VyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlRyaWVkIHRvIGRpc3BhdGNoIGFuIHVucmVnaXN0ZXJlZCBhY3Rpb24gXCIgKyAocmVkdWNlciAmJiAodHlwZW9mIHJlZHVjZXIgPT09IFwic3RyaW5nXCIgPyByZWR1Y2VyIDogcmVkdWNlci5uYW1lKSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBVbnJlZ2lzdGVyZWRBY3Rpb25FcnJvcjtcbn0oRXJyb3IpKTtcbnZhciBTdG9yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZShpbml0aWFsU3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFwiYXVyZWxpYS1zdG9yZVwiKTtcbiAgICAgICAgdGhpcy5kZXZUb29sc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgaXNVbmRvYWJsZSA9IHRoaXMub3B0aW9ucy5oaXN0b3J5ICYmIHRoaXMub3B0aW9ucy5oaXN0b3J5LnVuZG9hYmxlID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX3N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZXZUb29sc09wdGlvbnMgfHwgdGhpcy5vcHRpb25zLmRldlRvb2xzT3B0aW9ucy5kaXNhYmxlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRGV2VG9vbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRvYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlckhpc3RvcnlNZXRob2RzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBwbGFjZW1lbnQsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMuc2V0KHJlZHVjZXIsIHsgcGxhY2VtZW50OiBwbGFjZW1lbnQsIHNldHRpbmdzOiBzZXR0aW5ncyB9KTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XG4gICAgICAgIGlmICh0aGlzLm1pZGRsZXdhcmVzLmhhcyhyZWR1Y2VyKSkge1xuICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlcy5kZWxldGUocmVkdWNlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5pc01pZGRsZXdhcmVSZWdpc3RlcmVkID0gZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZXMuaGFzKG1pZGRsZXdhcmUpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyQWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHJlZHVjZXIpIHtcbiAgICAgICAgaWYgKHJlZHVjZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVkdWNlciBpcyBleHBlY3RlZCB0byBoYXZlIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMsIHdoZXJlIHRoZSBmaXJzdCB3aWxsIGJlIHRoZSBwcmVzZW50IHN0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucy5zZXQocmVkdWNlciwgeyB0eXBlOiBuYW1lIH0pO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJBY3Rpb24gPSBmdW5jdGlvbiAocmVkdWNlcikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmhhcyhyZWR1Y2VyKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmRlbGV0ZShyZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmlzQWN0aW9uUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5hY3Rpb25zKS5maW5kKGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvblsxXS50eXBlID09PSByZWR1Y2VyOyB9KSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMuaGFzKHJlZHVjZXIpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnJlc2V0VG9TdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS5uZXh0KHN0YXRlKTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5sb29rdXBBY3Rpb24ocmVkdWNlcik7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFVucmVnaXN0ZXJlZEFjdGlvbkVycm9yKHJlZHVjZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZURpc3BhdGNoKFt7XG4gICAgICAgICAgICAgICAgcmVkdWNlcjogYWN0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgICB9XSk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChyZWR1Y2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGlwZWxpbmUgPSBbXTtcbiAgICAgICAgdmFyIGRpc3BhdGNoUGlwZSA9IHtcbiAgICAgICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5xdWV1ZURpc3BhdGNoKHBpcGVsaW5lKTsgfSxcbiAgICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uIChuZXh0UmVkdWNlcikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLmxvb2t1cEFjdGlvbihuZXh0UmVkdWNlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVucmVnaXN0ZXJlZEFjdGlvbkVycm9yKHJlZHVjZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaXBlbGluZS5wdXNoKHsgcmVkdWNlcjogYWN0aW9uLCBwYXJhbXM6IG5leHRQYXJhbXMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoUGlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoUGlwZS5waXBlLmFwcGx5KGRpc3BhdGNoUGlwZSwgW3JlZHVjZXJdLmNvbmNhdChwYXJhbXMpKTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5sb29rdXBBY3Rpb24gPSBmdW5jdGlvbiAocmVkdWNlcikge1xuICAgICAgICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBBcnJheS5mcm9tKHRoaXMuYWN0aW9ucykuZmluZChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgXyA9IF9hWzBdLCBhY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLnR5cGUgPT09IHJlZHVjZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aW9ucy5oYXMocmVkdWNlcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUucXVldWVEaXNwYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNwYXRjaFF1ZXVlLnB1c2goeyBhY3Rpb25zOiBhY3Rpb25zLCByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kaXNwYXRjaFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmhhbmRsZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVJdGVtLCBlXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmRpc3BhdGNoUXVldWUubGVuZ3RoID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVJdGVtID0gdGhpcy5kaXNwYXRjaFF1ZXVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5pbnRlcm5hbERpc3BhdGNoKHF1ZXVlSXRlbS5hY3Rpb25zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVJdGVtLnJlamVjdChlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUuaW50ZXJuYWxEaXNwYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1bnJlZ2lzdGVyZWRBY3Rpb24sIHBpcGVkQWN0aW9ucywgY2FsbGluZ0FjdGlvbiwgYmVmb3JlTWlkZGxlc3dhcmVzUmVzdWx0LCByZXN1bHQsIF9pLCBwaXBlZEFjdGlvbnNfMSwgYWN0aW9uLCByZXN1bHRpbmdTdGF0ZSwgbWVhc3VyZXMsIG1hcmtzLCB0b3RhbER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJlZEFjdGlvbiA9IGFjdGlvbnMuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gIV90aGlzLmFjdGlvbnMuaGFzKGEucmVkdWNlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVucmVnaXN0ZXJlZEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnJlZ2lzdGVyZWRBY3Rpb25FcnJvcih1bnJlZ2lzdGVyZWRBY3Rpb24ucmVkdWNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5tYXJrKFwiZGlzcGF0Y2gtc3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXBlZEFjdGlvbnMgPSBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfdGhpcy5hY3Rpb25zLmdldChhLnJlZHVjZXIpLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWR1Y2VyOiBhLnJlZHVjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmdBY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGlwZWRBY3Rpb25zLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlOyB9KS5qb2luKFwiLT5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwaXBlZEFjdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChwLCBhKSB7IHJldHVybiBwLmNvbmNhdChhLnBhcmFtcyk7IH0sIFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXBlZEFjdGlvbnM6IHBpcGVkQWN0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGEudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhLnBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9nRGlzcGF0Y2hlZEFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcltnZXRMb2dUeXBlKHRoaXMub3B0aW9ucywgXCJkaXNwYXRjaGVkQWN0aW9uc1wiLCBMb2dMZXZlbC5pbmZvKV0oXCJEaXNwYXRjaGluZzogXCIgKyBjYWxsaW5nQWN0aW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5leGVjdXRlTWlkZGxld2FyZXModGhpcy5fc3RhdGUuZ2V0VmFsdWUoKSwgTWlkZGxld2FyZVBsYWNlbWVudC5CZWZvcmUsIGNhbGxpbmdBY3Rpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlTWlkZGxlc3dhcmVzUmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU1pZGRsZXN3YXJlc1Jlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5jbGVhck1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUExBVEZPUk0ucGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGJlZm9yZU1pZGRsZXN3YXJlc1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgcGlwZWRBY3Rpb25zXzEgPSBwaXBlZEFjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgcGlwZWRBY3Rpb25zXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBwaXBlZEFjdGlvbnNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhY3Rpb24ucmVkdWNlci5hcHBseShhY3Rpb24sIFtyZXN1bHRdLmNvbmNhdChhY3Rpb24ucGFyYW1zKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBMQVRGT1JNLnBlcmZvcm1hbmNlLmNsZWFyTWFya3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgUExBVEZPUk0ucGVyZm9ybWFuY2UubWFyayhcImRpc3BhdGNoLWFmdGVyLXJlZHVjZXItXCIgKyBhY3Rpb24udHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlZHVjZXIgaGFzIHRvIHJldHVybiBhIG5ldyBzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZXhlY3V0ZU1pZGRsZXdhcmVzKHJlc3VsdCwgTWlkZGxld2FyZVBsYWNlbWVudC5BZnRlciwgY2FsbGluZ0FjdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdTdGF0ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRpbmdTdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5jbGVhck1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUExBVEZPUk0ucGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0YXRlSGlzdG9yeShyZXN1bHRpbmdTdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlzdG9yeSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaXN0b3J5LmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nU3RhdGUgPSBhcHBseUxpbWl0cyhyZXN1bHRpbmdTdGF0ZSwgdGhpcy5vcHRpb25zLmhpc3RvcnkubGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUubmV4dChyZXN1bHRpbmdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5tYXJrKFwiZGlzcGF0Y2gtZW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWFzdXJlUGVyZm9ybWFuY2UgPT09IFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQuU3RhcnRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5tZWFzdXJlKFwic3RhcnRFbmREaXNwYXRjaER1cmF0aW9uXCIsIFwiZGlzcGF0Y2gtc3RhcnRcIiwgXCJkaXNwYXRjaC1lbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZXMgPSBQTEFURk9STS5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFwic3RhcnRFbmREaXNwYXRjaER1cmF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyW2dldExvZ1R5cGUodGhpcy5vcHRpb25zLCBcInBlcmZvcm1hbmNlTG9nXCIsIExvZ0xldmVsLmluZm8pXShcIlRvdGFsIGR1cmF0aW9uIFwiICsgbWVhc3VyZXNbMF0uZHVyYXRpb24gKyBcIiBvZiBkaXNwYXRjaGVkIGFjdGlvbiBcIiArIGNhbGxpbmdBY3Rpb24ubmFtZSArIFwiOlwiLCBtZWFzdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWVhc3VyZVBlcmZvcm1hbmNlID09PSBQZXJmb3JtYW5jZU1lYXN1cmVtZW50LkFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gUExBVEZPUk0ucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZShcIm1hcmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbiA9IG1hcmtzW21hcmtzLmxlbmd0aCAtIDFdLnN0YXJ0VGltZSAtIG1hcmtzWzBdLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcltnZXRMb2dUeXBlKHRoaXMub3B0aW9ucywgXCJwZXJmb3JtYW5jZUxvZ1wiLCBMb2dMZXZlbC5pbmZvKV0oXCJUb3RhbCBkdXJhdGlvbiBcIiArIHRvdGFsRHVyYXRpb24gKyBcIiBvZiBkaXNwYXRjaGVkIGFjdGlvbiBcIiArIGNhbGxpbmdBY3Rpb24ubmFtZSArIFwiOlwiLCBtYXJrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5jbGVhck1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQTEFURk9STS5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURldlRvb2xzU3RhdGUoeyB0eXBlOiBjYWxsaW5nQWN0aW9uLm5hbWUsIHBhcmFtczogY2FsbGluZ0FjdGlvbi5wYXJhbXMgfSwgcmVzdWx0aW5nU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5leGVjdXRlTWlkZGxld2FyZXMgPSBmdW5jdGlvbiAoc3RhdGUsIHBsYWNlbWVudCwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWlkZGxld2FyZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7IHJldHVybiBtaWRkbGV3YXJlWzFdLnBsYWNlbWVudCA9PT0gcGxhY2VtZW50OyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyciwgXywgX2FycikgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2EsIF9iLCBfYywgZV8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFswLCA1LCA3LCA4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IGN1cnIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJldl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2IuYXBwbHkoX2EsIFtfZC5zZW50KCksIHRoaXMuX3N0YXRlLmdldFZhbHVlKCksIGN1cnJbMV0uc2V0dGluZ3MsIGFjdGlvbl0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXJyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHByZXZdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IChfZC5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBfY107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvcGFnYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXJyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcHJldl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9kLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIFBMQVRGT1JNLnBlcmZvcm1hbmNlLm1hcmsoXCJkaXNwYXRjaC1cIiArIHBsYWNlbWVudCArIFwiLVwiICsgY3VyclswXS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSwgc3RhdGUpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnNldHVwRGV2VG9vbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChQTEFURk9STS5nbG9iYWwuZGV2VG9vbHNFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2dldExvZ1R5cGUodGhpcy5vcHRpb25zLCBcImRldlRvb2xzU3RhdHVzXCIsIExvZ0xldmVsLmRlYnVnKV0oXCJEZXZUb29scyBhcmUgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5kZXZUb29sc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRldlRvb2xzID0gUExBVEZPUk0uZ2xvYmFsLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18uY29ubmVjdCh0aGlzLm9wdGlvbnMuZGV2VG9vbHNPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZGV2VG9vbHMuaW5pdCh0aGlzLmluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmRldlRvb2xzLnN1YnNjcmliZShmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlcltnZXRMb2dUeXBlKF90aGlzLm9wdGlvbnMsIFwiZGV2VG9vbHNTdGF0dXNcIiwgTG9nTGV2ZWwuZGVidWcpXShcIkRldlRvb2xzIHNlbnQgY2hhbmdlIFwiICsgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcIkRJU1BBVENIXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0YXRlLm5leHQoSlNPTi5wYXJzZShtZXNzYWdlLnN0YXRlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS51cGRhdGVEZXZUb29sc1N0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGV2VG9vbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGV2VG9vbHMuc2VuZChhY3Rpb24sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVySGlzdG9yeU1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJBY3Rpb24oXCJqdW1wXCIsIGp1bXApO1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlO1xufSgpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoaWZ5KGFjdGlvbikge1xuICAgIHZhciBzdG9yZSA9IENvbnRhaW5lci5pbnN0YW5jZS5nZXQoU3RvcmUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaC5hcHBseShzdG9yZSwgW2FjdGlvbl0uY29uY2F0KHBhcmFtcykpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVTdGVwcyhzdG9yZSwgc2hvdWxkTG9nUmVzdWx0cykge1xuICAgIHZhciBzdGVwcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0ZXBzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2dTdGVwLCB0cnlTdGVwLCBsYXN0U3RlcDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgbG9nU3RlcCA9IGZ1bmN0aW9uIChzdGVwLCBzdGVwSWR4KSB7IHJldHVybiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZExvZ1Jlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cChcIlN0ZXAgXCIgKyBzdGVwSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGVwKHJlcyk7XG4gICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgdHJ5U3RlcCA9IGZ1bmN0aW9uIChzdGVwLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYXN0U3RlcCA9IGZ1bmN0aW9uIChzdGVwLCByZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcChyZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzdGVwcy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuc3RhdGUucGlwZShza2lwKGN1cnJlbnRTdGVwKSwgdGFrZSgxKSwgZGVsYXkoMCkpLnN1YnNjcmliZSh0cnlTdGVwKGxvZ1N0ZXAoc3RlcCwgY3VycmVudFN0ZXApLCByZWplY3QpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwKys7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5zdGF0ZS5waXBlKHNraXAoY3VycmVudFN0ZXApLCB0YWtlKDEpKS5zdWJzY3JpYmUobGFzdFN0ZXAodHJ5U3RlcChsb2dTdGVwKHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdLCBjdXJyZW50U3RlcCksIHJlamVjdCksIHJlc29sdmUpKTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG52YXIgZGVmYXVsdFNlbGVjdG9yID0gZnVuY3Rpb24gKHN0b3JlKSB7IHJldHVybiBzdG9yZS5zdGF0ZTsgfTtcbmZ1bmN0aW9uIGNvbm5lY3RUbyhzZXR0aW5ncykge1xuICAgIHZhciAkc3RvcmU7XG4gICAgLy8gY29uc3Qgc3RvcmUgPSBDb250YWluZXIuaW5zdGFuY2UuZ2V0KFN0b3JlKSBhcyBTdG9yZTxUPjtcbiAgICB2YXIgX3NldHRpbmdzID0gX19hc3NpZ24oeyBzZWxlY3RvcjogdHlwZW9mIHNldHRpbmdzID09PSBcImZ1bmN0aW9uXCIgPyBzZXR0aW5ncyA6IGRlZmF1bHRTZWxlY3RvciB9LCBzZXR0aW5ncyk7XG4gICAgZnVuY3Rpb24gZ2V0U291cmNlKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIGlmIGZvciBzb21lIHJlYXNvbiBnZXRTb3VyY2UgaXMgaW52b2tlZCBiZWZvcmUgc2V0dXAgKGJpbmQgbGlmZWN5Y2xlLCB0eXBpY2FsbHkpXG4gICAgICAgIC8vIHRoZW4gd2UgaGF2ZSBubyBjaG9pY2UgYnV0IHRvIGdldCB0aGUgc3RvcmUgaW5zdGFuY2UgZnJvbSBnbG9iYWwgY29udGFpbmVyIGluc3RhbmNlXG4gICAgICAgIC8vIG90aGVyd2lzZSwgYXNzdW1lIHRoYXQgJHN0b3JlIHZhcmlhYmxlIGluIHRoZSBjbG9zdXJlIHdvdWxkIGJlIGFscmVhZHkgYXNzaWduZWQgdGhlIHJpZ2h0XG4gICAgICAgIC8vIHZhbHVlIGZyb20gY3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAvLyBDb3VsZCBhbHNvIGJlIGluIHNpdHVhdGlvbiB3aGVyZSBpdCBkb2Vzbid0IGNvbWUgZnJvbSBjdXN0b20gZWxlbWVudCwgb3Igc29tZSBleG90aWMgc2V0dXBzL3NjZW5hcmlvc1xuICAgICAgICB2YXIgc3RvcmUgPSAkc3RvcmUgfHwgKCRzdG9yZSA9IENvbnRhaW5lci5pbnN0YW5jZS5nZXQoU3RvcmUpKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlbGVjdG9yKHN0b3JlKTtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLnN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGlzU2VsZWN0b3JPYmogPSB0eXBlb2YgX3NldHRpbmdzLnNlbGVjdG9yID09PSBcIm9iamVjdFwiO1xuICAgICAgICB2YXIgZmFsbGJhY2tTZWxlY3RvciA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbX3NldHRpbmdzLnRhcmdldCB8fCBcInN0YXRlXCJdID0gX3NldHRpbmdzLnNlbGVjdG9yIHx8IGRlZmF1bHRTZWxlY3RvcixcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKF9fYXNzaWduKHt9LCAoaXNTZWxlY3Rvck9iaiA/IF9zZXR0aW5ncy5zZWxlY3RvciA6IGZhbGxiYWNrU2VsZWN0b3IpKSkubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9hWzBdLCBzZWxlY3RvciA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0czogX3NldHRpbmdzLnRhcmdldCAmJiBpc1NlbGVjdG9yT2JqID8gW19zZXR0aW5ncy50YXJnZXQsIHRhcmdldF0gOiBbdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgLy8gbnVtYmVycyBhcmUgdGhlIHN0YXJ0aW5nIGluZGV4IHRvIHNsaWNlIGFsbCB0aGUgY2hhbmdlIGhhbmRsaW5nIGFyZ3MsIFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFyZSBwcm9wIG5hbWUsIG5ldyBzdGF0ZSBhbmQgb2xkIHN0YXRlXG4gICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnM6IChfYiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYltfc2V0dGluZ3Mub25DaGFuZ2VkIHx8IFwiXCJdID0gMSxcbiAgICAgICAgICAgICAgICAgICAgX2JbKF9zZXR0aW5ncy50YXJnZXQgfHwgdGFyZ2V0KSArIFwiQ2hhbmdlZFwiXSA9IF9zZXR0aW5ncy50YXJnZXQgPyAwIDogMSxcbiAgICAgICAgICAgICAgICAgICAgX2JbXCJwcm9wZXJ0eUNoYW5nZWRcIl0gPSAwLFxuICAgICAgICAgICAgICAgICAgICBfYilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ3JlYXRlZCA9IHRhcmdldC5wcm90b3R5cGUuY3JlYXRlZDtcbiAgICAgICAgdmFyIG9yaWdpbmFsU2V0dXAgPSB0eXBlb2Ygc2V0dGluZ3MgPT09IFwib2JqZWN0XCIgJiYgc2V0dGluZ3Muc2V0dXBcbiAgICAgICAgICAgID8gdGFyZ2V0LnByb3RvdHlwZVtzZXR0aW5ncy5zZXR1cF1cbiAgICAgICAgICAgIDogdGFyZ2V0LnByb3RvdHlwZS5iaW5kO1xuICAgICAgICB2YXIgb3JpZ2luYWxUZWFyZG93biA9IHR5cGVvZiBzZXR0aW5ncyA9PT0gXCJvYmplY3RcIiAmJiBzZXR0aW5ncy50ZWFyZG93blxuICAgICAgICAgICAgPyB0YXJnZXQucHJvdG90eXBlW3NldHRpbmdzLnRlYXJkb3duXVxuICAgICAgICAgICAgOiB0YXJnZXQucHJvdG90eXBlLnVuYmluZDtcbiAgICAgICAgLy8gb25seSBvdmVycmlkZSBpZiBwcm90b3R5cGUgY2FsbGJhY2sgaXMgYSBmdW5jdGlvblxuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsQ3JlYXRlZCA9PT0gXCJmdW5jdGlvblwiIHx8IG9yaWdpbmFsQ3JlYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXQucHJvdG90eXBlLmNyZWF0ZWQgPSBmdW5jdGlvbiBjcmVhdGVkKF8sIHZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIHJlbGllcyBvbiB0aGUgZmFjdCB0aGF0IHRoZSBjbGFzcyBTdG9yZVxuICAgICAgICAgICAgICAgIC8vIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHNvbWV3aGVyZSBpbiBvbmUgb2YgY2hpbGQgY29udGFpbmVycywgaW5zdGVhZCBvZiByb290IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpc3N1ZSB3aXRoIHRoaXMgYXBwcm9hY2gsIG5lZWRzIHRvIHdhbGsgYWxsIHRoZSB3YXkgdXAgdG8gcmVzb2x2ZSBmcm9tIHJvb3RcbiAgICAgICAgICAgICAgICAvLyB0eXBpY2FsbHkgbGlrZSBpbnZva2luZyBmcm9tIGdsb2JhbCBDb250YWluZXIuaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAkc3RvcmUgPSB2aWV3LmNvbnRhaW5lci5nZXQoU3RvcmUpO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENyZWF0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDcmVhdGVkLmNhbGwodGhpcywgXywgdmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucHJvdG90eXBlW3R5cGVvZiBzZXR0aW5ncyA9PT0gXCJvYmplY3RcIiAmJiBzZXR0aW5ncy5zZXR1cCA/IHNldHRpbmdzLnNldHVwIDogXCJiaW5kXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZXR0aW5ncy5vbkNoYW5nZWQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAhKHNldHRpbmdzLm9uQ2hhbmdlZCBpbiB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVkIG9uQ2hhbmdlZCBoYW5kbGVyIGRvZXMgbm90IGV4aXN0IG9uIHRhcmdldCBWTVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3Vic2NyaXB0aW9ucyA9IGNyZWF0ZVNlbGVjdG9ycygpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gZ2V0U291cmNlKHMuc2VsZWN0b3IpLnN1YnNjcmliZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRhcmdldElkeCA9IHMudGFyZ2V0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHMudGFyZ2V0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3UsIGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3UgPT09IHZvaWQgMCkgeyBhY2N1ID0ge307IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VbY3Vycl07XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHMuY2hhbmdlSGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IF9hWzBdLCBhcmdzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyTmFtZSBpbiBfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNbaGFuZGxlck5hbWVdLmFwcGx5KF90aGlzLCBbcy50YXJnZXRzW2xhc3RUYXJnZXRJZHhdLCBzdGF0ZSwgb2xkU3RhdGVdLnNsaWNlKGFyZ3MsIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHMudGFyZ2V0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3UsIGN1cnIsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1W2N1cnJdID0gaWR4ID09PSBsYXN0VGFyZ2V0SWR4ID8gc3RhdGUgOiBhY2N1W2N1cnJdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdVtjdXJyXTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTZXR1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFNldHVwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5wcm90b3R5cGVbdHlwZW9mIHNldHRpbmdzID09PSBcIm9iamVjdFwiICYmIHNldHRpbmdzLnRlYXJkb3duID8gc2V0dGluZ3MudGVhcmRvd24gOiBcInVuYmluZFwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVN1YnNjcmlwdGlvbnMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLl9zdGF0ZVN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uICYmIHN1Yi5jbG9zZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsVGVhcmRvd24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxUZWFyZG93bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZShhdXJlbGlhLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmluaXRpYWxTdGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0aWFsU3RhdGUgbXVzdCBiZSBwcm92aWRlZCB2aWEgb3B0aW9uc1wiKTtcbiAgICB9XG4gICAgdmFyIGluaXRTdGF0ZSA9IG9wdGlvbnMuaW5pdGlhbFN0YXRlO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGlzdG9yeSAmJiBvcHRpb25zLmhpc3RvcnkudW5kb2FibGUgJiYgIWlzU3RhdGVIaXN0b3J5KG9wdGlvbnMuaW5pdGlhbFN0YXRlKSkge1xuICAgICAgICBpbml0U3RhdGUgPSB7IHBhc3Q6IFtdLCBwcmVzZW50OiBvcHRpb25zLmluaXRpYWxTdGF0ZSwgZnV0dXJlOiBbXSB9O1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5pbml0aWFsU3RhdGU7XG4gICAgYXVyZWxpYS5jb250YWluZXJcbiAgICAgICAgLnJlZ2lzdGVySW5zdGFuY2UoU3RvcmUsIG5ldyBTdG9yZShpbml0U3RhdGUsIG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0IHsgY29uZmlndXJlLCBQZXJmb3JtYW5jZU1lYXN1cmVtZW50LCBVbnJlZ2lzdGVyZWRBY3Rpb25FcnJvciwgU3RvcmUsIGRpc3BhdGNoaWZ5LCBleGVjdXRlU3RlcHMsIGp1bXAsIG5leHRTdGF0ZUhpc3RvcnksIGFwcGx5TGltaXRzLCBpc1N0YXRlSGlzdG9yeSwgREVGQVVMVF9MT0NBTF9TVE9SQUdFX0tFWSwgTWlkZGxld2FyZVBsYWNlbWVudCwgbG9nTWlkZGxld2FyZSwgbG9jYWxTdG9yYWdlTWlkZGxld2FyZSwgcmVoeWRyYXRlRnJvbUxvY2FsU3RvcmFnZSwgTG9nTGV2ZWwsIExvZ2dlckluZGV4ZWQsIGdldExvZ1R5cGUsIGNvbm5lY3RUbyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aurelia-store\n");

/***/ })

}]);